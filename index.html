<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>발로란트 내전 전적 시스템</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#151925;--panel-2:#1a2030;--accent:#6aa0ff;--accent-2:#9bffe0;
      --text:#e8ecf1;--muted:#9aa4b2;--danger:#ff7188;--win:#4fd1a5;--loss:#ff8b6a;
      --border:#242b3d;--chip:#1f2740;--gold:#f2c94c;
      --good:#7ee787;--bad:#ff7b72;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Pretendard,Helvetica,Arial,sans-serif}
    a{color:var(--accent)}
    header{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,rgba(15,17,21,.95),rgba(15,17,21,.85));backdrop-filter: blur(8px);border-bottom:1px solid var(--border)}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tab{padding:10px 14px;border:1px solid var(--border);background:var(--panel);border-radius:10px;cursor:pointer;color:var(--muted)}
    .tab.active{background:var(--panel-2);color:var(--text);border-color:#2a3247}
    main .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;margin:16px 0}
    h2{margin:0 0 12px;font-size:20px}
    h3{margin:14px 0 8px}
    .grid{display:grid;gap:12px}
    .g2{grid-template-columns:repeat(2,1fr)}
    .g3{grid-template-columns:repeat(3,1fr)}
    @media (max-width:900px){.g2,.g3{grid-template-columns:1fr}}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type="text"],input[type="date"],textarea,select{
      width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:#0e1422;color:var(--text);outline:none
    }
    textarea{min-height:220px;resize:vertical}
    .btn{padding:10px 14px;border:1px solid var(--border);background:var(--panel-2);color:var(--text);border-radius:10px;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#3352ff,#2035ad);border-color:#2a41d1}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .right{margin-left:auto}
    .muted{color:var(--muted)}
    .chip{display:inline-flex;align-items:center;gap:6px;background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:12px}
    .agent-badge{display:inline-flex;align-items:center;gap:8px;background:#0e1629;border:1px solid #223053;border-radius:12px;padding:6px 10px}
    .agent-badge img{width:22px;height:22px;border-radius:6px;object-fit:cover;background:#091122}
    .badge-win{color:var(--win)}
    .badge-loss{color:var(--loss)}
    .list{width:100%;border-collapse:collapse}
    .list th,.list td{border-bottom:1px solid var(--border);padding:10px 8px;text-align:left}
    .list tr:hover{background:#121829}
    .center{text-align:center}
    .pagination{display:flex;gap:8px;justify-content:center;margin-top:12px}
    .pagination .page{min-width:38px;height:38px;display:inline-flex;align-items:center;justify-content:center;border-radius:10px;border:1px solid var(--border);background:var(--panel-2);cursor:pointer}
    .pagination .page.active{outline:2px solid var(--accent)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:var(--panel-2);font-size:12px}
    .win{color:var(--win)} .loss{color:var(--loss)}
    .table-tight th,.table-tight td{padding:6px 8px}
    .card{background:var(--panel-2);border:1px solid var(--border);border-radius:14px;padding:12px}
    .scroll-x{overflow:auto}
    .small{font-size:12px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .divider{height:1px;background:var(--border);margin:10px 0}
    .note{background:rgba(255, 236, 179,.08);border:1px solid #3a3320;padding:10px;border-radius:10px}
    .ok{color:var(--good)} .ng{color:var(--bad)}
    .toast{position:fixed;right:16px;bottom:16px;background:#162033;border:1px solid #243256;color:#eaf2ff;border-radius:12px;padding:10px 14px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:999}
    .hidden{display:none}
    /* modal */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:100}
    .modal.show{display:flex}
    .modal .box{max-width:1000px;width:100%;background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px}
    .footnote{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div class="row" style="gap:10px">
        <div class="chip"><strong>VALORANT</strong> 내전 전적 시스템</div>
        <span class="muted small">Firestore 실시간 • 단일 파일</span>
      </div>
      <div class="right"></div>
    </div>
    <div class="tabs" id="tabs">
      <div class="tab active" data-tab="input">내전 정보 입력</div>
      <div class="tab" data-tab="matches">내전 전적</div>
      <div class="tab" data-tab="search">전적 검색</div>
      <div class="tab" data-tab="tiers">티어표</div>
    </div>
  </div>
</header>

<main class="wrap">
  <!-- 내전 정보 입력 (간소화) -->
  <section id="tab-input" class="panel">
    <h2>내전 정보 입력</h2>
    <div class="card">
      <div class="grid g3">
        <div>
          <label>맵 이름</label>
          <input id="mapName" type="text" placeholder="예: Ascent / Haven / Bind / OVP 등" />
        </div>
        <div>
          <label>최종 스코어</label>
          <input id="finalScore" type="text" placeholder="예: 13-11" />
        </div>
        <div>
          <label>경기 날짜</label>
          <input id="matchDate" type="date" />
        </div>
      </div>
      <div class="divider"></div>
      <div class="grid">
        <div>
          <label>내전 정보 입력칸 (원문 붙여넣기)</label>
          <textarea id="rawPaste" placeholder="여기에 전체를 붙여넣으세요.&#10;예:&#10;네온&#10;백종명#KR1&#10;플래티넘 2&#10;플래티넘&#10;-&#10;OVP&#10;24 / 23 / 8&#10;1.39:1&#10;246.17&#10;147 +0 13% 6 6 0&#10;...&#10;승리적군 ..."></textarea>
        </div>
        <div class="row">
          <button id="btnParse" class="btn">원문 파싱</button>
          <div class="right">
            <button id="btnSaveMatch" class="btn primary">저장</button>
          </div>
        </div>
      </div>
      <div class="note small" style="margin-top:8px">
        <b>포맷</b> — <span class="pill">요원</span> → <span class="pill">닉네임#태그</span> → <span class="pill">상세 티어</span> → <span class="pill">대분류 티어</span> → <span class="pill">-</span> → <span class="pill">순위(MVP/3rd…)</span> → <span class="pill">K/D/A</span> → <span class="pill">비율</span> → <span class="pill">ACS</span> → <span class="pill">ADR DDΔ HS% FK FD MK</span> … 5인 입력 후 <span class="pill">승리적군/승리아군</span> → 나머지 5인
      </div>
    </div>

    <div id="preview" class="card" style="margin-top:12px">
      <b>파싱 미리보기</b>
      <div id="previewBody" class="small muted" style="margin-top:6px">아직 파싱하지 않았습니다.</div>
    </div>
  </section>

  <!-- 내전 전적 -->
  <section id="tab-matches" class="panel hidden">
    <h2>내전 전적</h2>
    <div class="row" style="gap:10px">
      <div class="chip">실시간 동기화</div>
      <div class="chip"><span class="muted">정렬:</span>
        <select id="matchSort">
          <option value="date_desc">최신순</option>
          <option value="date_asc">오래된순</option>
          <option value="map_asc">맵(A→Z)</option>
        </select>
      </div>
      <div class="right row" style="gap:8px">
        <input id="matchSearch" type="text" placeholder="맵 이름 검색…" />
      </div>
    </div>

    <div class="scroll-x" style="margin-top:10px">
      <table class="list" id="matchTable">
        <thead>
        <tr>
          <th>맵</th><th>스코어</th><th>팀 결과</th><th>경기 날짜</th><th class="center">보기</th>
        </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div id="pagination" class="pagination"></div>
  </section>

  <!-- 전적 검색 -->
  <section id="tab-search" class="panel hidden">
    <h2>전적 검색</h2>
    <div class="row" style="gap:10px">
      <input id="searchQuery" type="text" placeholder="닉네임#태그 (예: Stargazer#0921)" />
      <button id="btnSearch" class="btn">검색</button>
      <span class="muted small">저장된 매치 데이터 기반으로 즉시 집계합니다.</span>
    </div>
    <div id="searchResult" class="grid" style="margin-top:12px"></div>
  </section>

  <!-- 티어표 -->
  <section id="tab-tiers" class="panel hidden">
    <h2>티어표</h2>
    <div class="scroll-x">
      <table class="list table-tight" id="tierTable">
        <thead>
        <tr>
          <th>#</th><th>티어</th><th>MMR</th><th>닉네임</th><th>내전 총 게임</th><th>승</th><th>패</th><th>승률</th>
        </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="divider"></div>
    <h3>MMR 가중치 및 변동 로직</h3>
    <div class="grid g2">
      <div class="card">
        <b>기본 규칙</b>
        <ul>
          <li>모든 유저는 <span class="pill">골드 2 (MMR 2000)</span>에서 시작</li>
          <li>기본 승/패: <span class="ok">+25</span> / <span class="ng">-25</span></li>
          <li>2단 승급(보너스): 최근 10판 중 <b>연승 4+</b> & <b>MVP ≥ 3</b> 달성 시 그 판에서 <b>+10</b> (표기상 2단 승급)</li>
        </ul>
        <b>성능 보정 (한 판 기준, 최대 ±20 캡)</b>
        <ul>
          <li>ACS 등수 보정: 팀 내 ACS 등수에 따라 <span class="ok">+8</span> ~ <span class="ng">-8</span></li>
          <li>ADR/ DDΔ/ HS%는 <b>모든 팀원이 0이 아닐 때만</b> 보정 적용</li>
          <li>FK/FD/MK: (FK-FD)*2 + MK*1 (±6 캡)</li>
        </ul>
        <b>패배 완화 / 승리 축소</b>
        <ul>
          <li>졌지만 상위 퍼포먼스(팀 ACS 1~2위 & ADR 상위): <span class="ok">+6</span></li>
          <li>이겼지만 하위 퍼포먼스(팀 ACS 4~5위 & ADR 하위): <span class="ng">-6</span></li>
        </ul>
        <div class="footnote">※ 보정 합산은 한 판당 최종 보정 ±20으로 캡</div>
      </div>
      <div class="card" id="mmrHistoryBox">
        <b>최근 MMR 변동 내역</b>
        <div id="mmrHistory" class="small muted">데이터 로딩 중…</div>
      </div>
    </div>
  </section>
</main>

<div id="modal" class="modal">
  <div class="box">
    <div class="row">
      <h3 style="margin:0">매치 상세</h3>
      <button id="btnCloseModal" class="btn right">닫기</button>
    </div>
    <div id="modalContent"></div>
  </div>
</div>

<div id="toast" class="toast hidden"></div>

<!-- Firebase (ESM) -->
<script type="module">
  /* ---------------- Firebase ---------------- */
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getFirestore, collection, addDoc, serverTimestamp, onSnapshot, doc, getDoc,
    setDoc, updateDoc, query, orderBy, getDocs, limit
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  const firebaseConfig = {apiKey:"AIzaSyDw2nAlGyepFTQQVN8m6slQmtLyc5vR0_s",authDomain:"valo-cf536.firebaseapp.com",projectId:"valo-cf536",storageBucket:"valo-cf536.appspot.com",messagingSenderId:"463328045633",appId:"1:463328045633:web:7785fd381903d8cee874c0"};
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  /* ---------------- Helpers ---------------- */
  const $ = (s)=>document.querySelector(s);
  const el = (tag,attrs={},...children)=>{
    const n=document.createElement(tag);
    Object.entries(attrs).forEach(([k,v])=>{
      if(k==='class') n.className=v;
      else if(k==='html') n.innerHTML=v;
      else n.setAttribute(k,v);
    });
    children.forEach(c=>{
      if(typeof c==='string') n.appendChild(document.createTextNode(c));
      else if(c) n.appendChild(c);
    });
    return n;
  };
  const toast=(m)=>{const t=$('#toast');t.textContent=m;t.classList.remove('hidden');setTimeout(()=>t.classList.add('hidden'),2200);};
  const fmtDate=(d)=>{if(!(d instanceof Date)) d=new Date(d); const y=d.getFullYear(),m=('0'+(d.getMonth()+1)).slice(-2),day=('0'+d.getDate()).slice(-2); return `${y}-${m}-${day}`;};
  const parseDateInput=()=>{ const v=$('#matchDate').value; if(!v) return new Date(); return new Date(v+'T12:00:00'); };

  /* ---------------- Tabs ---------------- */
  const switchTab=(name)=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.toggle('active',x.dataset.tab===name));
    document.querySelectorAll('main > section').forEach(sec=>sec.classList.toggle('hidden',sec.id!=='tab-'+name));
  };
  $('#tabs').addEventListener('click',(e)=>{
    const t=e.target.closest('.tab'); if(!t) return; switchTab(t.dataset.tab);
  });

  /* ---------------- Agent icon (optional) ---------------- */
  const agentIconMap={};
  function agentCell(name){
    const wrap = el('div',{class:'agent-badge'});
    if(agentIconMap[name]){
      const img=el('img',{src:agentIconMap[name],alt:name,onerror:"this.remove();"});
      wrap.append(img);
    }else{
      wrap.append(el('div',{class:'chip'},name||'요원'));
    }
    wrap.append(el('span',{},name||'요원'));
    return wrap;
  }

  /* ---------------- Parser (새/구 포맷 겸용, 구 포맷 강화) ---------------- */

  function splitTeamBlocks(raw){
    // '승리아군' or '승리적군' line splits A/B
    const parts = raw.replace(/\r/g,'').split(/\n\s*승리[^\n]*\n/);
    if(parts.length===1) return [parts[0], ''];
    return [parts[0], parts[1]];
  }

  // 새 포맷(요약 티어+태그, '평균 점수' 라벨)도 계속 지원
  function parseCompactBlock(text){
    const lines=text.split('\n').map(s=>s.trim()).filter(Boolean);
    const players=[]; let i=0;
    while(i<lines.length && players.length<5){
      const agent=lines[i++]||'';
      const tierTag=lines[i++]||''; // P2닉#태그 or 닉#태그
      const kdaLine=lines[i++]||'';
      if(lines[i]==='-') i++;
      const place=(lines[i]||'').includes('평균 점수')?'—':(lines[i++]||'—');
      if(lines[i]==='평균 점수') i++;
      const acs=parseFloat(lines[i++]||'0')||0;

      const kdaMatch=kdaLine.match(/(\d+)\s*\/\s*(\d+)\s*\/\s*(\d+)/);
      const k=kdaMatch?+kdaMatch[1]:0, d=kdaMatch?+kdaMatch[2]:0, a=kdaMatch?+kdaMatch[3]:0;

      // 태그는 뒤쪽 부분(요약티어 제거)
      const tag = tierTag.replace(/^[A-Z][a-z]?\d?/,'').trim();

      players.push({agent, tag, rankDetail:'', tier:'', place, k,d,a, acs,
        adr:0, ddd:0, hs:0, fk:0, fd:0, mk:0});
    }
    return players;
  }

  // ★ 핵심: 구 포맷(ADR DDΔ HS% FK FD MK가 한 줄에 모두 있는 경우) 강력 파서
  function parseLegacyTailBlock(text){
    // 플레이어 블록은: agent \n tag \n rankDetail \n tier \n - \n place \n kda \n ratio \n acs \n "ADR DDΔ HS% FK FD MK"
    const blocks = text
      .replace(/\r/g,'')
      .split(/\n(?=[가-힣A-Za-z].*\n.*#)/g) // agent line followed by tag with '#'
      .map(s=>s.trim())
      .filter(Boolean)
      .slice(0,5);

    const out=[];
    for(const blk of blocks){
      const ls = blk.split('\n').map(x=>x.trim()).filter(x=>x.length>0);
      if(ls.length < 9) continue;

      const agent = ls[0];
      const tag = ls[1];                     // ex) 설 화#Wh1te
      const rankDetail = ls[2] || '언랭크';  // ex) 플래티넘 2
      const tier = ls[3] || '언랭크';        // ex) 플래티넘

      let j = 4;
      if(ls[j] === '-') j++;                 // skip '-'

      const place = ls[j++] || '—';          // ex) MVP / 3rd ...
      const kdaLine = ls[j++] || '0 / 0 / 0';
      if(/\d+(\.\d+)?:\d+/.test(ls[j]||'')) j++; // ratio like "1.39:1" (optional)
      const acs = parseFloat(ls[j++] || '0') || 0;

      // metrics line: "ADR  DDΔ  HS%  FK  FD  MK"
      const metricsLine = (ls[j++] || '').replace(/\t+/g,' ').replace(/\s+/g,' ').trim();
      const parts = metricsLine.split(' ');
      // Some inputs may look like "147 +0 13% 6 6 0"
      const adr = parseFloat(parts[0] || '0') || 0;
      const ddd = parseInt((parts[1] || '0').replace('+',''),10) * (String(parts[1]||'').startsWith('-')? -1 : 1);
      const hs  = parseInt((parts[2] || '0').replace('%',''),10) || 0;
      const fk  = parseInt(parts[3] || '0',10) || 0;
      const fd  = parseInt(parts[4] || '0',10) || 0;
      const mk  = parseInt(parts[5] || '0',10) || 0;

      const m = kdaLine.match(/(\d+)\s*\/\s*(\d+)\s*\/\s*(\d+)/);
      const k = m?+m[1]:0, d = m?+m[2]:0, a = m?+m[3]:0;

      out.push({agent, tag, rankDetail, tier, place, k, d, a, acs, adr, ddd, hs, fk, fd, mk});
    }
    return out;
  }

  function parseRaw(raw){
    const [partA, partB] = splitTeamBlocks(raw);
    // Try compact first
    let A = parseCompactBlock(partA);
    let B = parseCompactBlock(partB);
    // If not 5, use legacy (enhanced)
    if(A.length<5) A = parseLegacyTailBlock(partA);
    if(B.length<5) B = parseLegacyTailBlock(partB);
    return {A, B, marker: (raw.includes('승리아군')?'ally': (raw.includes('승리적군')?'enemy':'none'))};
  }

  /* -------------- Preview & Save -------------- */
  let lastParsed = null;

  function renderPreview(parsed){
    const box = $('#previewBody'); box.innerHTML='';
    const makeTable=(team, won)=>{
      const tbl = el('table',{class:'list table-tight'});
      tbl.append(el('thead',{}, el('tr',{},
        el('th',{},'요원'), el('th',{},'닉네임'), el('th',{},'순위'),
        el('th',{},'K / D / A'), el('th',{},'ACS'), el('th',{},'ADR'), el('th',{},'DDΔ'), el('th',{},'HS%'), el('th',{},'FK/FD/MK')
      )));
      const tb=el('tbody',{});
      team.forEach(p=>{
        tb.append(el('tr',{},
          el('td',{}, agentCell(p.agent)),
          el('td',{}, p.tag),
          el('td',{}, p.place||'—'),
          el('td',{}, `${p.k} / ${p.d} / ${p.a}`),
          el('td',{}, String(p.acs)),
          el('td',{}, String(p.adr||0)),
          el('td',{}, String(p.ddd||0)),
          el('td',{}, (p.hs||0)+'%'),
          el('td',{}, `${p.fk||0}/${p.fd||0}/${p.mk||0}`)
        ));
      });
      tbl.append(tb);
      return tbl;
    };
    const aWon = parsed.marker ? false : true; // 구분선 있으면 B가 승
    box.append(
      el('div',{class:'row'}, el('b',{}, 'Team A'), el('span',{class:'pill'}, aWon?'승?':'패?')),
      makeTable(parsed.A, aWon),
      el('div',{class:'divider'}),
      el('div',{class:'row'}, el('b',{}, 'Team B'), el('span',{class:'pill'}, aWon?'패?':'승?')),
      makeTable(parsed.B, !aWon)
    );
  }

  $('#btnParse').addEventListener('click', ()=>{
    const raw = $('#rawPaste').value.trim();
    if(!raw){ toast('원문을 붙여넣어 주세요.'); return; }
    const parsed = parseRaw(raw);
    if(parsed.A.length!==5 || parsed.B.length!==5){
      toast(`파싱 인원 A:${parsed.A.length} / B:${parsed.B.length} — 형식을 확인해주세요.`);
    }else{
      toast('파싱 성공! 아래 미리보기와 함께 저장할 수 있어요.');
    }
    lastParsed = parsed;
    renderPreview(parsed);
  });

  /* ----------------- Tier / MMR ----------------- */
  const baseMMR=2000;
  const tiers=[
    {name:'아이언', base:1200},
    {name:'브론즈', base:1500},
    {name:'실버', base:1800},
    {name:'골드', base:2000},
    {name:'플래티넘', base:2150},
    {name:'다이아몬드', base:2300},
    {name:'에센트', base:2500},
    {name:'이모탈', base:2700},
    {name:'레디언트', base:3000},
  ];
  function mmrToTier(mmr){
    let t=tiers[0].name, div=3;
    for(const x of tiers){ if(mmr>=x.base) t=x.name; }
    const base=tiers.find(x=>x.name===t).base; const delta=Math.max(0,mmr-base);
    if(t==='레디언트'){div=1;} else div=delta>=120?1: delta>=60?2:3;
    return `${t} ${div}`;
  }

  async function getRecent10(tag){
    const ref = collection(db,'players', tag, 'mmr_history');
    const qd = query(ref, orderBy('ts','desc'), limit(10));
    const snap = await getDocs(qd);
    let wins=0,mvps=0,winstreak=0,losestreak=0, cur=0, type=null;
    snap.forEach(d=>{
      const h=d.data();
      if(h.won){ wins++; if(type!==true){cur=0;type=true;} cur++; } else { if(type!==false){cur=0;type=false;} cur++; }
      if(type===true) winstreak=Math.max(winstreak,cur); else losestreak=Math.max(losestreak,cur);
      if(h.place==='MVP') mvps++;
    });
    return {wins,mvps,winstreak,losestreak};
  }

  function computeMMRDelta(ctx){
    let delta = ctx.won?25:-25;
    const reasons=[ctx.won?'+25 (승리)':'-25 (패배)'];

    // ACS 등수 보정
    const acsSorted=[...ctx.teamStats].sort((a,b)=>b.acs-a.acs);
    const rankACS = acsSorted.findIndex(p=>p.tag===ctx.player.tag)+1;
    const acsAdj = [0,+8,+4,-2,-4,-8][rankACS] ?? 0;
    if(acsAdj){ delta+=acsAdj; reasons.push(`${acsAdj>0?'+':''}${acsAdj} (팀 ACS ${rankACS}위)`); }

    // ADR 보정(모두 0이면 스킵)
    const adrs = ctx.teamStats.map(p=>p.adr||0);
    const allADRZero = adrs.every(x=>x===0);
    if(!allADRZero){
      const meanADR = adrs.reduce((a,b)=>a+b,0)/adrs.length||0;
      const sdADR = Math.sqrt(adrs.map(x=>(x-meanADR)**2).reduce((a,b)=>a+b,0)/adrs.length)||1;
      let adrAdj = ((ctx.player.adr-meanADR)/sdADR)*2;
      adrAdj = Math.max(-4, Math.min(4, adrAdj));
      if(adrAdj){ delta+=adrAdj; reasons.push(`${adrAdj>=0?'+':''}${adrAdj.toFixed(1)} (ADR 상대보정)`); }
    }

    // DDΔ 보정(모두 0이면 스킵)
    const allDDDZero = ctx.teamStats.every(p=>(p.ddd||0)===0);
    if(!allDDDZero){
      const raw = ctx.player.ddd||0;
      let dddAdj = Math.max(-6, Math.min(6, Math.round(Math.abs(raw)/100)*2)) * (raw<0?-1:1);
      if(dddAdj){ delta+=dddAdj; reasons.push(`${dddAdj>=0?'+':''}${dddAdj} (DDΔ)`); }
    }

    // HS% 보정(모두 0이면 스킵)
    const hsAllZero = ctx.teamStats.every(p=>(p.hs||0)===0);
    if(!hsAllZero){
      const hsAvg = ctx.teamStats.reduce((a,b)=>a+(b.hs||0),0)/ctx.teamStats.length||0;
      const diffHS = (ctx.player.hs||0)-hsAvg;
      let hsAdj = 0; if(diffHS>=10) hsAdj=+3; else if(diffHS<=-10) hsAdj=-3;
      if(hsAdj){ delta+=hsAdj; reasons.push(`${hsAdj>0?'+':''}${hsAdj} (HS%)`); }
    }

    // FK/FD/MK 보정
    let fAdj = ((ctx.player.fk||0) - (ctx.player.fd||0))*2 + ((ctx.player.mk||0)*1);
    fAdj = Math.max(-6, Math.min(6, fAdj));
    if(fAdj){ delta+=fAdj; reasons.push(`${fAdj>0?'+':''}${fAdj} (FK/FD/MK)`); }

    // 패배 완화/승리 축소
    const meanADR2 = adrs.reduce((a,b)=>a+b,0)/adrs.length||0;
    const topPerf = (rankACS<=2) && (allADRZero ? true : (ctx.player.adr>=meanADR2));
    const lowPerf = (rankACS>=4) && (allADRZero ? true : (ctx.player.adr<meanADR2));
    if(!ctx.won && topPerf){ delta+=6; reasons.push('+6 (패배 완화: 상위 퍼포먼스)'); }
    if(ctx.won && lowPerf){ delta-=6; reasons.push('-6 (승리 축소: 하위 퍼포먼스)'); }

    // 성능 보정 캡
    const perf = delta - (ctx.won?25:-25);
    if(perf>20){ delta=(ctx.won?25:-25)+20; reasons.push('(보정 상한 +20 적용)'); }
    if(perf<-20){ delta=(ctx.won?25:-25)-20; reasons.push('(보정 하한 -20 적용)'); }

    // 연승+MVP 보너스
    const r = ctx.recent10||{wins:0,mvps:0,winstreak:0,losestreak:0};
    if(r.winstreak>=4 && r.mvps>=3){ delta+=10; reasons.push('+10 (연승4+ & MVP≥3)'); reasons.push('(표기상 2단 승급)'); }

    return {delta:Math.round(delta), reasons};
  }

  async function ensurePlayer(tag){
    const ref = doc(db,'players', tag);
    const snap = await getDoc(ref);
    if(!snap.exists()){
      await setDoc(ref,{tag, mmr:baseMMR, tier:mmrToTier(baseMMR), total:0, wins:0, losses:0, createdAt:serverTimestamp(), updatedAt:serverTimestamp()});
    }
    return ref;
  }

  async function updateAggregatesForMatch(matchId, matchDate, mapName, score, teamA, teamB, aWon){
    const all=[...teamA,...teamB];
    for(const p of all){
      const ref = await ensurePlayer(p.tag);
      const snap = await getDoc(ref);
      const cur = snap.data()||{};
      const isA = teamA.some(x=>x.tag===p.tag);
      const won = aWon ? isA : !isA;

      const teamStats = isA?teamA:teamB;
      const recent = await getRecent10(p.tag);
      const mmrRes = computeMMRDelta({won, teamStats, player:p, recent10:recent});
      const newMMR = (cur.mmr||baseMMR)+mmrRes.delta;
      const tierStr = mmrToTier(newMMR);

      await updateDoc(ref,{
        mmr:newMMR, tier:tierStr,
        total:(cur.total||0)+1,
        wins:(cur.wins||0)+(won?1:0),
        losses:(cur.losses||0)+(won?0:1),
        updatedAt:serverTimestamp()
      });

      await addDoc(collection(db,'players', p.tag, 'mmr_history'),{
        ts:serverTimestamp(), matchId, mapName, score, date:matchDate, delta:mmrRes.delta, reasons:mmrRes.reasons, won, place:p.place||'—'
      });
    }
  }

  $('#btnSaveMatch').addEventListener('click', async ()=>{
    const mapName = $('#mapName').value.trim();
    const score = $('#finalScore').value.trim();
    if(!mapName || !score){ toast('맵 이름과 스코어를 입력하세요.'); return; }
    if(!lastParsed || lastParsed.A.length!==5 || lastParsed.B.length!==5){
      toast('먼저 "원문 파싱"으로 10명을 인식해주세요.'); return;
    }
    const dt = parseDateInput();
    // 구분선(승리xx)이 있었다면 B팀 승
    const aWon = lastParsed.marker ? false : true;

    const docRef = await addDoc(collection(db,'matches'),{
      mapName, score, matchDate: dt, teamA:lastParsed.A, teamB:lastParsed.B, aWon, savedAt: serverTimestamp()
    });
    await updateAggregatesForMatch(docRef.id, dt, mapName, score, lastParsed.A, lastParsed.B, aWon);
    toast('저장 완료! 내전 전적 탭에서 확인하세요.');
    switchTab('matches');
    $('#rawPaste').value=''; lastParsed=null; $('#previewBody').textContent='아직 파싱하지 않았습니다.';
  });

  /* ---------------- Matches (list/paging) ---------------- */
  let allMatches=[], filteredMatches=[], currentPage=1; const pageSize=10;

  function renderPagination(){
    const totalPages=Math.max(1, Math.ceil(filteredMatches.length/pageSize));
    const box=$('#pagination'); box.innerHTML='';
    const btn=(label,page,active,disabled)=>{
      const b=el('div',{class:'page'+(active?' active':''),'data-page':page},label);
      if(disabled){ b.style.opacity='.5'; b.style.pointerEvents='none'; }
      box.append(b);
    };
    btn('이전',Math.max(1,currentPage-1),false,currentPage===1);
    const start=Math.max(1,currentPage-2), end=Math.min(totalPages,start+4);
    for(let p=start;p<=end;p++) btn(String(p),p,p===currentPage);
    btn('다음',Math.min(totalPages,currentPage+1),false,currentPage===totalPages);
  }
  $('#pagination').addEventListener('click',(e)=>{
    const b=e.target.closest('.page'); if(!b) return;
    const p=parseInt(b.dataset.page,10); if(!isFinite(p)) return;
    currentPage=p; renderMatchTable();
  });

  function renderMatchTable(){
    const tbody=$('#matchTable tbody'); tbody.innerHTML='';
    const start=(currentPage-1)*pageSize, end=Math.min(filteredMatches.length,start+pageSize);
    for(let i=start;i<end;i++){
      const m=filteredMatches[i];
      const tr=el('tr',{});
      tr.append(
        el('td',{},m.mapName||'-'),
        el('td',{},m.score||'-'),
        el('td',{}, m.aWon?el('span',{class:'win'},'Team A 승'):el('span',{class:'loss'},'Team B 승')),
        el('td',{}, fmtDate(m.matchDate||m.savedAt)),
        el('td',{class:'center'}, el('button',{class:'btn','data-id':m.id,onclick:'window.viewMatch(this.dataset.id)'},'상세'))
      );
      tbody.append(tr);
    }
    renderPagination();
  }

  function applyMatchFilters(){
    const q=$('#matchSearch').value.trim().toLowerCase();
    let arr=[...allMatches];
    if(q) arr=arr.filter(m=>(m.mapName||'').toLowerCase().includes(q));
    const sort=$('#matchSort').value;
    if(sort==='date_desc') arr.sort((a,b)=>(b.matchDate||b.savedAt)-(a.matchDate||a.savedAt));
    if(sort==='date_asc') arr.sort((a,b)=>(a.matchDate||a.savedAt)-(b.matchDate||b.savedAt));
    if(sort==='map_asc') arr.sort((a,b)=> (a.mapName||'').localeCompare(b.mapName||''));
    filteredMatches=arr; currentPage=1; renderMatchTable();
  }
  $('#matchSort').addEventListener('change',applyMatchFilters);
  $('#matchSearch').addEventListener('input',applyMatchFilters);

  async function loadMatches(){
    onSnapshot(collection(db,'matches'),(snap)=>{
      const arr=[];
      snap.forEach(d=>{
        const x=d.data();
        arr.push({
          id:d.id, mapName:x.mapName, score:x.score, aWon:x.aWon,
          teamA:x.teamA||[], teamB:x.teamB||[],
          savedAt:x.savedAt?.toDate?.()||new Date(0),
          matchDate:x.matchDate?.toDate?.()||x.savedAt?.toDate?.()||new Date(0)
        });
      });
      allMatches = arr.sort((a,b)=> (b.matchDate||b.savedAt)-(a.matchDate||a.savedAt));
      applyMatchFilters();
      loadTierBoard();
      loadMMRHistory();
    });
  }
  loadMatches();

  // 상세 모달
  window.viewMatch=(id)=>{
    const m=allMatches.find(x=>x.id===id); if(!m) return;
    const box=$('#modalContent'); box.innerHTML='';
    const makeTeam=(team,won)=>{
      const wrap=el('div',{class:'card'});
      wrap.append(el('div',{class:'row'}, el('b',{}, won?'Team (승)':'Team (패)'), el('span',{class:'right pill'},`플레이어 ${team.length}명`)));
      const tbl=el('table',{class:'list table-tight'});
      tbl.append(el('thead',{}, el('tr',{},
        el('th',{},'요원'), el('th',{},'닉네임'), el('th',{},'순위'),
        el('th',{},'K / D / A'), el('th',{},'ACS'), el('th',{},'ADR'), el('th',{},'DDΔ'), el('th',{},'HS%'), el('th',{},'FK/FD/MK')
      )));
      const tb=el('tbody',{});
      team.forEach(p=>{
        tb.append(el('tr',{},
          el('td',{},agentCell(p.agent)),
          el('td',{},p.tag),
          el('td',{},p.place||'—'),
          el('td',{},`${p.k} / ${p.d} / ${p.a}`),
          el('td',{},String(p.acs)),
          el('td',{},String(p.adr||0)),
          el('td',{},String(p.ddd||0)),
          el('td',{},(p.hs||0)+'%'),
          el('td',{},`${p.fk||0}/${p.fd||0}/${p.mk||0}`)
        ));
      });
      tbl.append(tb);
      wrap.append(tbl); return wrap;
    };
    box.append(
      el('div',{class:'row'},
        el('div',{}, el('span',{class:'pill'}, m.mapName), ' ', el('span',{class:'muted'}, fmtDate(m.matchDate))),
        el('div',{class:'right'}, el('span',{class:'chip'}, '스코어: '+m.score), ' ', el('span',{class: m.aWon?'badge-win':'badge-loss'}, m.aWon?'Team A 승':'Team B 승'))
      ),
      makeTeam(m.teamA, m.aWon),
      makeTeam(m.teamB, !m.aWon)
    );
    $('#modal').classList.add('show');
  };
  $('#btnCloseModal').addEventListener('click',()=>$('#modal').classList.remove('show'));
  $('#modal').addEventListener('click',(e)=>{ if(e.target.id==='modal') $('#modal').classList.remove('show'); });

  /* ---------------- Search ---------------- */
  $('#btnSearch').addEventListener('click',()=>doSearch($('#searchQuery').value.trim()));
  async function doSearch(tag){
    const box=$('#searchResult'); box.innerHTML='';
    if(!tag){ toast('닉네임#태그를 입력하세요.'); return; }
    const snap=await getDocs(collection(db,'matches'));
    const matches=[];
    snap.forEach(d=>{
      const m=d.data();
      const inA=(m.teamA||[]).find(p=>p.tag===tag);
      const inB=(m.teamB||[]).find(p=>p.tag===tag);
      if(inA||inB){
        matches.push({id:d.id,...m, savedAt:m.savedAt?.toDate?.()||new Date(0), matchDate:m.matchDate?.toDate?.()||m.savedAt?.toDate?.()||new Date(0), self:inA||inB, side:inA?'A':'B'});
      }
    });
    if(matches.length===0){ box.append(el('div',{class:'note'},`${tag} 기록이 없습니다.`)); return; }

    let total=0,wins=0,losses=0,K=0,D=0,A=0,sumACS=0,sumADR=0,sumDDD=0,sumHS=0,FK=0,FD=0,MK=0;
    const mapStats={}, agentStats={}, teamMateRates={}, vsRates={};

    for(const m of matches){
      total++; const won = (m.aWon && m.side==='A') || (!m.aWon && m.side==='B'); if(won) wins++; else losses++;
      const p=m.self; K+=p.k; D+=p.d; A+=p.a; sumACS+=p.acs; sumADR+=p.adr||0; sumDDD+=p.ddd||0; sumHS+=p.hs||0; FK+=p.fk||0; FD+=p.fd||0; MK+=p.mk||0;
      mapStats[m.mapName]=mapStats[m.mapName]||{w:0,l:0}; if(won) mapStats[m.mapName].w++; else mapStats[m.mapName].l++;
      agentStats[p.agent]=agentStats[p.agent]||{w:0,l:0}; if(won) agentStats[p.agent].w++; else agentStats[p.agent].l++;
      const mates=(m.side==='A'?m.teamA:m.teamB).filter(x=>x.tag!==tag);
      mates.forEach(x=>{ teamMateRates[x.tag]=teamMateRates[x.tag]||{w:0,l:0}; if(won) teamMateRates[x.tag].w++; else teamMateRates[x.tag].l++;});
      const opps=(m.side==='A'?m.teamB:m.teamA);
      opps.forEach(x=>{ vsRates[x.tag]=vsRates[x.tag]||{w:0,l:0}; if(won) vsRates[x.tag].l++; else vsRates[x.tag].w++;});
    }
    const avg=(x)=> total? (x/total):0; const pct=(w,l)=> (w+l? (w/(w+l)*100):0);

    const hdr=el('div',{class:'card'});
    hdr.append(
      el('div',{class:'row'},
        el('b',{},tag),
        el('span',{class:'pill'},`총 게임 ${total}`),
        el('span',{class:'pill'},`승 ${wins}`),
        el('span',{class:'pill'},`패 ${losses}`),
        el('span',{class:'pill'},`승률 ${pct(wins,losses).toFixed(1)}%`),
        el('span',{class:'right muted small'},`최근: ${fmtDate(matches.sort((a,b)=>b.matchDate-a.matchDate)[0].matchDate)}`)
      ),
      el('div',{class:'row',style:'margin-top:6px;gap:8px'},
        el('span',{class:'chip'},`총 K/D/A: ${K}/${D}/${A}`),
        el('span',{class:'chip'},`평균 ACS: ${avg(sumACS).toFixed(2)}`),
        el('span',{class:'chip'},`평균 ADR: ${avg(sumADR).toFixed(2)}`),
        el('span',{class:'chip'},`평균 DDΔ: ${avg(sumDDD).toFixed(2)}`),
        el('span',{class:'chip'},`평균 HS: ${avg(sumHS).toFixed(2)}%`),
        el('span',{class:'chip'},`총 FK/FD/MK: ${FK}/${FD}/${MK}`),
        el('span',{class:'chip'},`판당 FK/FD/MK: ${avg(FK).toFixed(2)}/${avg(FD).toFixed(2)}/${avg(MK).toFixed(2)}`)
      )
    );
    box.append(hdr);

    const mapCard=el('div',{class:'card'}); mapCard.append(el('b',{},'맵별 성적'));
    const mapTable=el('table',{class:'list table-tight'}); const tb1=el('tbody',{});
    mapTable.append(el('thead',{}, el('tr',{}, el('th',{},'맵'), el('th',{},'승'), el('th',{},'패'), el('th',{},'승률'))));
    Object.entries(mapStats).sort((a,b)=> (b[1].w+b[1].l)-(a[1].w+a[1].l)).forEach(([m,st])=>tb1.append(el('tr',{}, el('td',{},m), el('td',{},st.w), el('td',{},st.l), el('td',{}, pct(st.w,st.l).toFixed(1)+'%'))));
    mapTable.append(tb1); mapCard.append(mapTable); box.append(mapCard);

    const agCard=el('div',{class:'card'}); agCard.append(el('b',{},'요원별 성적'));
    const agTable=el('table',{class:'list table-tight'}); const tb2=el('tbody',{});
    agTable.append(el('thead',{}, el('tr',{}, el('th',{},'요원'), el('th',{},'승'), el('th',{},'패'), el('th',{},'승률'))));
    Object.entries(agentStats).sort((a,b)=> (b[1].w+b[1].l)-(a[1].w+a[1].l)).forEach(([ag,st])=>tb2.append(el('tr',{}, el('td',{},agentCell(ag)), el('td',{},st.w), el('td',{},st.l), el('td',{}, pct(st.w,st.l).toFixed(1)+'%'))));
    agTable.append(tb2); agCard.append(agTable); box.append(agCard);

    const mate=el('div',{class:'card'}); mate.append(el('b',{},'같은 팀 승률'));
    const mt=el('table',{class:'list table-tight'}); const tb3=el('tbody',{});
    mt.append(el('thead',{}, el('tr',{}, el('th',{},'플레이어'), el('th',{},'같이한 판수'), el('th',{},'승률'))));
    Object.entries(teamMateRates).sort((a,b)=> (b[1].w+b[1].l)-(a[1].w+a[1].l)).forEach(([tg,st])=>tb3.append(el('tr',{}, el('td',{},tg), el('td',{},st.w+st.l), el('td',{}, pct(st.w,st.l).toFixed(1)+'%'))));
    mt.append(tb3); mate.append(mt); box.append(mate);

    const vr=el('div',{class:'card'}); vr.append(el('b',{},'상대팀 승률'));
    const vt=el('table',{class:'list table-tight'}); const tb4=el('tbody',{});
    vt.append(el('thead',{}, el('tr',{}, el('th',{},'플레이어'), el('th',{},'맞붙은 판수'), el('th',{},'상대팀 승률(상대 기준)'))));
    Object.entries(vsRates).sort((a,b)=> (b[1].w+b[1].l)-(a[1].w+a[1].l)).forEach(([tg,st])=>{
      const total=st.w+st.l; tb4.append(el('tr',{}, el('td',{},tg), el('td',{},total), el('td',{}, pct(st.w,st.l).toFixed(1)+'%')));
    });
    vt.append(tb4); vr.append(vt); box.append(vr);
  }

  /* ---------------- Tier board ---------------- */
  async function loadTierBoard(){
    const snap=await getDocs(collection(db,'players'));
    const arr=[];
    snap.forEach(d=>{ const x=d.data(); arr.push({tag:x.tag, mmr:x.mmr||baseMMR, tier:x.tier||mmrToTier(x.mmr||baseMMR), total:x.total||0, wins:x.wins||0, losses:x.losses||0}); });
    arr.sort((a,b)=>b.mmr-a.mmr);
    const tb=$('#tierTable tbody'); tb.innerHTML='';
    arr.forEach((p,idx)=>{
      const wr=(p.total? (p.wins/p.total*100):0).toFixed(1)+'%';
      tb.append(el('tr',{}, el('td',{},String(idx+1)), el('td',{},p.tier), el('td',{},String(p.mmr)), el('td',{},p.tag), el('td',{},String(p.total)), el('td',{},String(p.wins)), el('td',{},String(p.losses)), el('td',{},wr)));
    });
  }
  async function loadMMRHistory(){
    const players = await getDocs(collection(db,'players'));
    const all=[];
    for(const p of players.docs){
      const ref=collection(db,'players', p.id, 'mmr_history');
      const qd=query(ref, orderBy('ts','desc'), limit(4));
      const hs=await getDocs(qd);
      hs.forEach(h=>all.push({tag:p.id, ...h.data()}));
    }
    all.sort((a,b)=> (b.ts?.toDate?.()||0)-(a.ts?.toDate?.()||0));
    const box=$('#mmrHistory'); box.innerHTML='';
    if(all.length===0){ box.textContent='기록이 없습니다.'; return; }
    all.slice(0,12).forEach(h=>{
      const line=el('div',{},
        el('span',{class:'mono'}, fmtDate(h.date?.toDate?.()||h.ts?.toDate?.()||new Date())),
        ' — ', el('b',{},h.tag),' ',
        el('span',{class: h.delta>=0?'ok':'ng'}, (h.delta>=0?'+':'')+h.delta),
        ' ', el('span',{class:'muted'}, `(${h.mapName} ${h.score} ${h.won?'승':'패'} / ${h.place||'—'})`),
        el('div',{class:'small muted'}, '사유: ' + (h.reasons||[]).join(', '))
      );
      box.append(line); box.append(el('div',{class:'divider'}));
    });
  }

  loadTierBoard();
</script>
</body>
</html>
